/* 하나가 아닌 여러개가 일렬로 나열되어 있을 때 이것을 리스트라고 한다. */

/* 
(data가 하나가 아닌 여러개라는 것이 공통점)	
	List(리스트)	   	       set(집합)
  (1,2,3)!=(3,2,1)			(1,2,3)=(1,2,3)
	순서가 있다!!			  순서가 없다!!
*/

/*
리스트
기본적인 연산: 삽입(insert), 삭제(remove), 검색(search) 등
리스트를 구현하는 대표적인 두 가지 방법: 배열, 연결리스트
<< 리스트는 1차원 배열임 >>
*/

/*
배열의 장점: 

1. 랜덤 엑세스가 가능함 
-> 예를 들어, 5번째 칸에 무얼 쓰거나 읽고 싶을 때, 시작주소+4*(한 칸의 크기)로 해주면 넣을 수 있다.
-> 임의의 n번째 칸에 접근하기 위해서도 똑같이 해주면 된다. 

배열의 단점: 

1. 배열은 크기가 고정되어진다 - reallocation (배열 재할당) 이 필요하다.
줄이거나 늘릴 수 없다.
통째로 옮겨서 reallocation하는 것도 비용이 많이 발생한다. 

2. 리스트의 중간에 원소를 삽입하거나 삭제할 경우 다수의 데이터를 옮겨야 한다.
*/

/*
연결리스트: 배열의 장점을 희생하는 대신 단점을 보완하는 것 !!

연결리스트의 장점:

1. 길이의 제한이 없다

2. 다른 데이터의 이동없이 중간에 삽입이나 삭제가 가능하다.

연결리스트의 단점:

1. 랜덤 엑세스가 불가능하다. 
*/

/*
배열: 메모리의 연속된 주소에 값들을 저장한다
-> 때문에, 사이에 무언가를 끼워넣고 싶으면 그냥 끼워넣을 수 있는 방법이 없다.

연결리스트: 저장하기 위해 순서대로 저장할 필요는 없다.
-> 순서관계를 표현하기 위해, 첫번째 주소와 그 다음 데이터의 주소 또한 같이 저장된다.
-> 데이터가 저장되는 주소 자체는 아무 관계가 없다.
-> 삭제하면 연결값 하나를 바꿔주면 된다. 

데이터와 그 다음 주소를 합해서 노드라고 한다. 
첫번째 노드의 주소는 따로 보관해야 한다 !!!!
*/

/*
연결리스트: 노드들이 링크들로 연결되어있는 자료구조이다.

노드: 데이터 필드 + 링크 필드 (다음 노드의 주소)
첫 번째 노드의 주소는 따로 저장해야 한다.
마지막 노드의 next 필드에는 NULL을 저장하여 연결리스트의 끝임을 표시해야 한다.
*/